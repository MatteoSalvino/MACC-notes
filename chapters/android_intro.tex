\chapter{Introduzione ad Android}
L'architettura hardware di un dispositivo è costituita da:
\begin{itemize}
    \item \textbf{Processore in banda base}: il quale ha il proprio sistema operativo in tempo reale, il quale pone i seguenti vincoli: il software che interagisce con le torri cellulari deve essere certificato, è proibito provare ad accedere alle stazioni di base e ha dei stringenti vincoli temporali.
    \item \textbf{Processore dell'applicazione}: esso esegue un sistema Linux basato sul kernel. Esso ha almeno due modalità: utente (non privilegiata) e kernel (privilegiata). Esse sono codificate in un registro della CPU come bits. Ogni tentativo di eseguire un'istruzione privilegiata quando tale processore è in modalità utente lancia un'eccezione. L'unico modo per cambiare modalità è utilizzare una specifica istruzione a livello utente (es. chiamata).
\end{itemize}

Android costruisce un ricco framework sopra al sottostrato di Linux, ma il suo nucleo fa affidamento su Linux per virtualizzare tutte le operazioni. L'ereditarietà di Linux consente ad Android di utilizzare le sue stesse caratteristiche di sicurezza: i permessi, le capacità, SELinux e altre protezioni di basso livello. Il modello di sicurezza di Linux è in relazione con il modello di sicurezza Unix. Questo modello fornisce le seguenti primitive:
\begin{itemize}
    \item Ogni utente ha il proprio numero unico identificativo (UID): due utenti potrebbero condividere lo stesso UID, ma questo in effetti significa che, in base a come il sistema è costruito, questo rappresenta un singolo utente con due combinazioni username/password.
    \item Ogni utente ha un id numerico di gruppo primario: simile allo username, il nome del gruppo non conta, e alcuni GID sono riservati per il sistema.
    \item Un utente può appartenere ad altri gruppi.
\end{itemize}

Android utilizza le precedenti primitive ma offre una differente interpretazione: gli utenti sono concessi per singole applicazioni, non per utenti umani. Un utente non può accedere alle risorse di un altro utente. Questo isolamento consente alle applicazioni di essere eseguite una accanto all'altra, senza essere in grado di influenzarsi a vicenda. Il \textbf{sandboxing} è un'ambiente in cui ogni applicazione durante l'installazione riceve la sua propria home directory. I permessi di Linux assegnati a questa directory permettono solamente al proprietario dell'applicazione di scrivere a e leggere da questa directory. Lo scopo di un permesso è di proteggere la privacy di un utente Android. Le applicazioni Android devono richiedere dei permessi per accedere a informazioni riservate dell'utente, così come per determinate caratteristiche del sistema (es. internet e la fotocamera). Utilizzare i permessi del filesystem per i files e i drivers del dispositivo, è possibile limitare i processi nell'accedere ad alcune funzionalità del dispositivo. Se un'applicazione ha richiesto l'accesso a qualche dispositivo e l'utente l'ha approvato, questa applicazione ha anche assegnato GID del dispositivo.

\section{Routines interne}
Android ha introdotto un meccanismo chiamato \textbf{Position Independent Executable (PIE)}, che esegue delle operazioni correttamente indipendentemente dal suo indirizzo assoluto. Esso viene comunemente utilizzato per le librerie condivise, così che il codice della libreria può essere caricato in una locazione dello spazio di indirizzi di ogni programma, senza utilizzare altre locazioni di memoria, ad esempio dedicate ad altre librerie condivise. Utilizzando tale approccio risparmiamo del tempo di rilocazione, a differenza del codice assoluto che doveva essere caricato ad una specifica locazione di memoria per funzionare correttamente. La protezione contro attacchi di buffer overflow viene aumentata, utilizzando la tecnica \textbf{Address Space Layout Randomization}, il quale rende parzialmente casuale l'indirizzo delle funzioni di libreria e delle più importanti aree di memoria. In questo modo l'attaccante che cerca di eseguire del codice malevolo su un computer è costretto a cercare gli indirizzi del codice e dei dati che gli servono prima di poterli utilizzare, causando una serie di crash del programma. Infatti, accedendo ad un indirizzo errato, si ottengono dati errati, e se viene chiamata una funzione con l'indirizzo errato verrà generata un'eccezione, causando la terminazione del programma. L'attaccante può sfruttare queste eccezioni per collezionare sempre più informazioni in modo da riuscire a conoscere prima o poi il corretto indirizzo di memoria di cui necessita. Questa attività di raccolta di informazioni genera una serie di crash del programma, che quindi sono ben visibili all'utente.

\section{Gestione della memoria}
Android non utilizza la tecnica dello scambio dei files, ma piuttosto gestisce la memoria dividendola in pagine e mappandola. Questo significa che la memoria che viene modificata da un'applicazione rimane residente nella RAM e non è possibile effettuare il paging. L'unico modo per rilasciare la memoria da un'applicazione è di rilasciare i riferimenti degli oggetti che tale applicazione mantiene, rendendo la memoria disponibile per il garbage collector. Per mantenere un ambiente multi-tasking funzionale, Android pone un limite sulla dimensione dell'heap per ciascun applicazione. La dimensione dipende da quanta memoria RAM è disponibile sul dispositivo. Se la nostra applicazione raggiunge la capacità dell'heap e prova ad allocare ancora memoria, esso può ricevere un  errore \textbf{Out Of Memory}. Nel caso in cui il sistema abbia bisogno di risorse, può decidere di terminare alcuni processi per liberare la RAM. In android, OOM killer è differente da quello tradizionale di Linux, visto che i processi sono classificati in base allo stato dell'applicazione corrente. Dopo che un'applicazione è stata terminata per richiedere risorse, può essere ripristinata, visto che il sistema operativo memorizza lo stato dell'applicazione nella cache. Un'applicazione Android in esecuzione è costituita da diversi processi, classificati come foreground, visibili, servizi, nascosti e vuoti. Per consentire lo scambio delle informazioni fra processi viene utilizzato \textbf{Inter-Process Communication}. Esso viene regolato dal \textbf{Binder}, il quale è un framework che contiene un oggetto centrale chiamato Binder driver che si occupa di gestire tutte le chiamate IPC. Il meccanismo di alto livello del Binder è chiamato \textbf{Intent}.

\section{Sequenza di boot}
Premendo il bottone di accensione, il codice ROM di avvio inizia l'esecuzione da una determinata locazione direttamente collegata alla ROM. Esso carico il \textbf{Boot Loader} nella RAM. Il boot loader è il codice che è eseguito prima del sistema operativo del dispositivo. Esso è costituito da codice di basso livello, il quale comunica al dispositivo come trovare ed eseguire il \textbf{kernel del sistema}. Tipicamente si trova nella memoria non volatile del sistema del dispositivo. Il kernel di Android è simile al kernel di Linux, visto che inizializza la cache, la memoria protetta, lo scheduling e carica i drivers. Quando queste attività sono state completate, esso cerca il processo \textbf{init} nel file system. Tale processo è il primo processo, infatti viene spesso chiamato il processo di root oppure il genitore di tutti gli altri processi. Tale processo esegue lo script init.rc che descrive i servizi del sistema, il file system e altri parametri che hanno bisogno di essere inizializzati. \textbf{Zygote} è un processo di macchina virtuale che viene eseguita durante la fase di avvio del sistema, lanciato dal processo init. In Java, noi sappiamo che diverse istanze di macchine virtuali appariranno in memoria per ogni applicazione che verrà eseguita. Se Android lancia diverse istanze di macchine virtuali Dalvik per ogni applicazione, allora consumerà molta memoria e tempo. Per questo motivo Android utilizza il processo Zygote. Infatti, esso permette di condividere il codice fra le macchine virtuali e avere dei minimi tempi di avvio. Il \textbf{System Server} è il primo componente Java da eseguire nel sistema, poichè esso esegue tutti i servizi Android come il manager della telefonia e il bluetooth, registrandoli con il gestore dei servizi. Le applicazioni accederanno a tali servizi attraverso un riferimento al gestore dei servizi.

\section{Android Runtime}
ART è un sistema software introdotto con Android 5.0 per andare a sostituire la macchina virtuale Dalvik. La macchina virtuale Dalvik è basata su tecnologia \textit{ust-in-time}, con il quale ogni applicazione viene compilata solamente in parte dallo sviluppatore e sarà poi di volta in volta compito della macchina virtuale eseguire il codice e compilarlo definitivamente il linguaggio macchina in tempo reale, per ogni esecuzione dell'applicazione stessa. ART invece è basato su tecnologia \textit{ahead-of-time} che esegue l'intera compilazione del codice durante l'installazione dell'applicazione e non durante l'esecuzione dell'applicazione stessa. Questo approccio richiederà un tempo maggiore per la fase di installazione, ma permette di incrementare le prestazioni e la gestione delle risorse in fase di esecuzione.

\section{Applicazioni}
Un'applicazione è generata utilizzando un linguaggio di programmazione. Essa sfrutta le librerie del sistema ma può anche effettuare direttamente delle system calls. Le librerie condivise sono tipicamente collegate al codice a run time. Il codice dell'applicazione e delle librerie viene copiato nella memoria principale e collegate fra di loro. Se due applicazioni utilizzano la stessa libreria, una copia di tale libreria è collegata in qualsiasi applicazione.

\subsection{Applicazioni native}
Le applicazioni native sono applicazioni sviluppate specificamente per un sistema operativo. Esse accedono alle librerie condivise e vengono eseguite direttamente dalla CPU. Vi sono due metodi per sviluppare questo tipo di applicazioni: \textbf{NDK} e \textbf{gcc}. I vantaggi di questo tipo di applicazioni sono:
\begin{itemize}
    \item Maggiore velocità, affidabilità e migliore reattività oltre che una risoluzione superiore che assicura una migliore UX.
    \item Semplice accesso a tutte le funzionalità del dispositivo.
    \item Notifiche push possibili solamente per questo tipo di applicazioni. Queste notifiche permettono di avvisare gli utenti e di attirare la loro attenzione ogni volta che lo desideriamo.
    \item Non necessitano obbligatoriamente di internet per funzionare.
\end{itemize}

Un possibile svantaggio è il loro costo di sviluppo vista la richiesta di sviluppatori esperti per un determinato ambiente e di manutenzione per le diverse versioni da aggiornare per le diverse piattaforme.
\subsubsection{Native Development Kit}
NDK è un insieme di strumenti che ci consentono di utilizzare codice C e C++ con Android. Lo strumento di default di compilazione di Android Studio per compilare librerie native è CMake. Esso viene utilizzato per controllare il processo di compilazione del software utilizzando una semplice piattaforma e files di configurazione indipendenti dal compilatore. Esso sfrutta il progetto \textbf{LLVM}. Essa è un'infrastruttura di compilazione scritta in C++, progettata per l'ottimizzazione di programmi in fase di compilazione, di linking, di esecuzione e di non utilizzo. Usando tale approccio, il programmatore può creare una macchina virtuale per linguaggi che la richiedono, un compilatore dipendente dall'architettura considerata e software di ottimizzazione del codice indipendenti dal tipo di linguaggio utilizzato o dalla piattaforma. La rappresentazione intermedia (IR) è indipendente sia dal linguaggio che dall'architettura; essa si pone fra il codice sorgente in un dato linguaggio e un generatore di codice per una specifica architettura. In questa fase il codice viene ottimizzato/trasformato sulla base di specifiche analisi. L'architettura di un'applicazione può seguire i seguenti approcci:
\begin{itemize}
    \item È scritta in Java/Kotlin con pochi metodi scritti in C/C++ che vengono acceduti attraverso la \textbf{Java Native Interface}.
    \item Tutte le activity sono implementate in C/C++.
\end{itemize}

\textbf{JNI} è un framework del linguaggi Java che consente al codice Java di richiamare il codice nativo scritto in altri linguaggi di programmazione, come C oppure C++. La sua principale applicazione è quella di richiamare all'interno di programmi Java porzioni di codice che svolgono funzionalità non portabili e che non possono essere implementate in linguaggio Java puro. Tale framework permette ai metodi nativi di utilizzare gli oggetti Java nello stesso modo in cui il codice Java li utilizza. Un metodo nativo può creare, ispezionare e aggiornare questi oggetti. Le funzioni native sono implementate in files .c oppure .cpp separati. Quando la JVM invoca la funzione, essa fornisce un puntatore JNIEnv, un puntatore jobject ad qualsiasi altro argomento dichiarato dal metodo Java. Il puntatore JNIEnv è una struttura che contiene l'interfaccia della JVM, la quale include tutte le funzioni necessarie per interagire con la JVM e per lavorare con gli oggetti Java. Il puntatore jobject è un riferimento all'oggetto Java all'interno del quale il metodo nativo è stato dichiarato. Un tipico utilizzo è la mappatura di tipi di dato nativi a tipi di dato Java.

\subsection{Applicazioni ibride}
Il meccanismo principale che ci consente di utilizzare Java e il codice nativo è il \textbf{Foreign Function Invocation (FFI)}. Esso è un meccanismo attraverso il quale un programma scritto in un linguaggio di programmazione può chiamare routines oppure fare uso di servizi scritto in un altro linguaggio. \textbf{Java Native Interface} è un'interfaccia che consente al codice java in esecuzione su una macchina virtuale java (JVM) di chiamare ed essere chiamato da applicazioni native e librerie scritte in altri linguaggi. Essa consente ai programmatori di scrivere dei metodi nativi per gestire situazioni quando un'applicazione non può essere scritta interamente in linguaggio Java, ad esempio quando le librerie Java non supportano una caratteristica specifica della piattaforma. JNI consente ai metodi nativi di utilizzare gli oggetti Java nello stesso modo in cui il codice Java utilizza questi oggetti. Inoltre, è possibile utilizzare codice Javascript dal codice Java dell'applicazione e viceversa. Infatti, basta rendere i metodi che si vogliono condividere lato Android pubblici, inserire l'annotazione @JavascriptInterface e aggiungere l'interfaccia con Javascript all'applicazione.

\subsubsection{Cordova}
Cordova fornisce un insieme di APIs che possono essere utilizzate per accedere ai servizi dei sistemi operativi mobili nativi come Camera, Geolocalizzazione, etc. Per accedere a tali servizi del dispositivo, vengono utilizzati degli oggetti Javascript attraverso delle chiamate alle APIs di Cordova. La sua architettura è costituita dai seguenti componenti:
\begin{itemize}
    \item \textbf{Webview}: essa fornisce un'interfaccia utente di un'applicazione Cordova e può essere anche utilizzata per essere un componente all'interno di un'applicazione ibrida più grande.
    \item \textbf{Web App}: essa è definita come la parte principale dove il codice dell'applicazione risiede. È semplicemente una pagina web creata utilizzando HTML, CSS e Javascript. Tipicamente, viene fornito un file locale (index.html) attraverso il quale è possibile fare riferimento al codice e ad altre risorse che sono necessarie per l'esecuzione dell'applicazione. L'applicazione viene eseguita in una WebView all'interno di un container nativo dell'applicazione, attraverso un motore di rendering HTML. Questo container è costituito da un file principale (config.xml), responsabile della comunicazione delle informazioni sull'applicazione.
    \item \textbf{Cordova plugin}: essi sono definiti come una parte integrale dell'ecosistema Cordova che forniscono un'interfaccia per Cordova e per la comunicazione fra componenti nativi. Essi forniscono anche un'interfaccia per le APIs standard del dispositivo (ci consentono di invocare del codice nativo dal codice Javascript). I plugin vengono classificati in \textbf{Principali}, i quali forniscono l'accesso ai servizi del dispositivo all' applicazione come Camera, Batteria, etc., e \textbf{Personalizzati} che forniscono dei bindings addizionali per servizi che non sono necessariamente disponibili su tutte le piattaforme.
\end{itemize}

Quando l'applicazione viene eseguita, Cordova carica la pagina di startup dell'applicazione (index.html) nella WebView dell'applicazione e fornisce il suo controllo alla WebView. Quest'ultima consente ad un utente di interagire con l'applicazione inserendo dei dati nei campi di input, cliccando dei bottoni e osservare i risultati ottenuti. Per accedere ai servizi del dispositivo come Contatti oppure Camera, Cordova fornisce un insieme di APIs Javascript che possono essere utilizzate dai sviluppatori dal loro codice Javascript. Le chiamate verranno tradotto in chiamate di API di codice nativo del dispositivo utilizzando un particolare strato di bridge. Le APIs native possono essere accedute attraverso i plugin di Cordova.

\subsubsection{Xamarin}
Xamarin è una piattaforma open-source per sviluppare applicazioni moderne e performanti per iOS, Android e Windows con .NET. Xamarin offre una strato di astrazione che gestisce la comunicazione del codice condiviso con il codice della piattaforma sottostante. Inoltre, esso viene eseguito in un ambiente controllato che fornisce dei metodi di supporto come l'allocazione della memoria e il garbage collection. Tale piattaforma consente a gli sviluppatori di condividere circa il 90\% delle loro applicazioni fra diversi sistemi operativi. Xamarin è costruito sopra a \textbf{Mono}, una versione open-source del framework .NET basato su gli standard .NET ECMA. Le applicazioni Xamarin.Android compilano dal linguaggio C\# in un linguaggio intermedio, il quale è compilato con la tecnologia \textit{just-in-time} in linguaggio macchina quando viene eseguita l'applicazione. Tali applicazioni vengono eseguite nell'ambiente di esecuzione Mono, fianco a fianco con la macchina virtuale ART. Inoltre, tale piattaforma fornisce dei bindings ai namespaces Android.* e Java.*. L'ambiente Mono effettua delle chiamate a tali namespaces attraverso un \textbf{Managed Callable Wrapper} e gli viene restituito il risultato attraverso un \textbf{Android Callable Wrapper}.

\subsection{Applicazioni mobile web}
Un'applicazione mobile web è un'applicazione che gira su un server web e che viene utilizzata attraverso un browser web, a differenza di una tradizionale applicazione desktop. Questo significa che gli utenti non dovranno installare l'applicazione sui loro smartphone e quindi la capacità di memoria del dispositivo non verrà influenzata. L'interfaccia utente deve essere ottimizzata per i dispositivi mobili che hanno schermi più piccoli e capacità funzionali legate al tocco con le mani. Tipicamente realizzare un'applicazione di questo tipo richiede meno disponibilità economica rispetto alle applicazioni native. Nonostante ciò, esse possono essere molto lente, non sfruttano al massimo le potenzialità del dispositivo e soprattutto sono totalmente dipendenti dalla connessione internet, non è possibile inviare notifiche push.

\subsubsection{Architettura}
L'idea per mostrare un'applicazione mobile web è di evitare di caricare continuamente la pagina di un determinato sito, bensì memorizzarla localmente. Ma come viene mostrata una pagina web nella nostra applicazione ? Viene eseguito il processo di rendering, nel quale il codice HTML viene tradotto, viene creato l'albero del dominio, viene tradotto il codice CSS, rilevando le sue regole e le direttive del layout. In tal modo abbiamo costruito un albero di rendering. In seguito viene eseguito il processo di layout, attraverso il quale viene assegnata la posizione fisica a ogni elemento da mostrare. Le posizioni vengono calcolate in base al viewport (i.e. area sullo schermo) disponibile. Ogni elemento HTML viene mostrato in una scatola chiamata \textbf{modello di scatola CSS}. Le sue dimensioni sono calcolate in base alla propria scatola genitore (container). La scatola genitore di livello più alto rappresenta la scatola del viewport. Molti browser supportano il meta tag viewport, il quale consente di settare il viewport per il processo di rendering. In particolare, esso consente di fornire il reale viewport attuale, così che il rendering viene effettuato sulla dimensione reale. Per gestire differenti viewport possiamo utilizzare due approcci:
\begin{itemize}
    \item Creare delle regole CSS per ogni tipologia di schermo. In generale, sono necessarie delle elaborazioni lato server.
    \item Definire delle regole CSS per lo schermo attuale, lato client (web reattivo). Esiste un framework chiamato \textbf{Bootstrap 4} che consente di definire delle scatole flessibili per il layout CSS, definendo come un container si adatta al viewport. Tale framework fornisce 5 breakpoints: \textbf{xs} per dispositivi extra small ($<$ 576px), \textbf{sm} per dispositivi small ($\geq$ 576px), \textbf{md} per dispositivi intermedi ($\geq$ 768px), \textbf{lg} per dispositivi grandi ($\geq$ 992px) e \textbf{xl} per dispositivi molto grandi ($\geq$ 1200px).
\end{itemize}

\subsection{Processo di compilazione}
Il processo di compilazione coinvolge molti strumenti e processi che convertono il nostro progetto in un Android Application Package (APK). Esso per un tipico modulo di applicazione Android segue questi passi:
\begin{enumerate}
    \item i compilatori convertono il codice sorgente in files DEX, i quali includono il bytecode in esecuzione sui dispositivi Android e ogni altra cosa nelle risorse compilate.
    \item il gestore dell'APK combina i files DEX e le risorse compilate in un singolo APK. Prima che la nostra applicazione possa essere installata e rilasciata su un dispositivo Android, l'APK deve essere firmata.
    \item il gestore dell'APK firma la nostra APK utilizzando la chiave di debug oppure di rilascio:
          \begin{itemize}
              \item se stiamo compilando una versione di debug dell'applicazione, cioè un'applicazione intesa solamente per profilazione e testing, il gestore firma la nostra applicazione con la chiave di debug.
              \item se stiamo compilando una versione di rilascio dell'applicazione che abbiamo intenzione di rilasciare esternamente, il gestore firma la nostra applicazione con la chiave di rilascio.
          \end{itemize}
    \item prima di generare l'APK finale, il gestore utilizza lo strumento zipalign per ottimizzare l'applicazione in modo da utilizzare meno memoria quando verrà eseguita sul dispositivo dell'utente finale.
\end{enumerate}

Android studio per automatizzare e gestire il processo di compilazione utilizza il toolkit \textbf{Gradle}. La personalizzazione delle configurazioni di compilazione è molto flessibile, infatti possiamo modificare le variabili dell'ambiente di compilazione che troviamo nel file .properties. Il processo di compilazione è controllato da diversi scripts utilizzando un DSL (linguaggio specifico del dominio). Il file setting.gradle comunica a Gradle quali moduli devono essere inclusi quando compiliamo l'applicazione. Il file build.gradle è un file di alto livello che definisce le configurazioni di compilazione che verranno applicate a tutti i moduli del progetto. Per default, tale file utilizza un blocco buildscript per definire le repositories e le dipendenze Gradle che sono comuni a tutti i moduli nel progetto. Possiamo definire diverse tipologie di dipendenze:
\begin{itemize}
    \item dipendenza su un modulo di libreria locale: il sistema di compilazione compila il modulo della libreria e incapsula il contenuto compilato nell'APK.
    \item dipendenza binaria locale: i files JAR già esistono.
    \item dipendenza binaria remota: implementazione di una libreria remota.
\end{itemize}
