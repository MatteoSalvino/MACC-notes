\documentclass[12pt]{report}

\usepackage[hidelinks=true]{hyperref}

\title{Appunti di Mobile Applications and Cloud Computing}
\author{Matteo Salvino}
\date{}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}


\begin{document}
\maketitle
\tableofcontents
\pagebreak

\chapter{Introduzione}
L' \textbf{architettura multi-strato} indica un'architettura software in cui le varie funzionalità del software sono logicamente separate su più strati in comunicazione fra loro. Nell'ambito delle applicazioni web questi strati sono :
\begin{itemize}
\item \textbf{strato di presentazione} : E' il livello più alto dell'applicazione. Esso mostra le informazioni relative a servizi, elaborate dagli strati di livello più basso.
\item \textbf{strato logico} : E' il livello che controlla le funzionalità di un'applicazione eseguendo elaborazioni dettagliate. In particolare, gestisce lo scambio di informazioni con lo strato di presentazione con varie elaborazioni e lo strato dei dati.
\item \textbf{strato dei dati} : E' il livello che si occupa dei dati. In tale strato le informazioni vengono memorizzate e recuperate. Il suo compito è di mantenere i dati neutrali e indipendenti dallo strato logico.
\end{itemize}
Ciascuno strato comunica direttamente con gli strati adiacenti, richiedendo ed offrendo servizi. Tale approccio fornisce un modello per gli sviluppatori per creare un'applicazione flessibile, riutilizzabile e di facilità mantenibilità, visto che è possibile modificare separatamente uno specifico strato, senza influenzare i rimanenti.\\\\Un \textbf{mashup} è un'applicazione web ibrida, cioè tale da essere costituita da contenuti provenienti da diverse fonti. Ad esempio, un'applicazione per la prenotazione di un tavolo in un particolare ristorante, dove viene mostrata la sua ubicazione utilizzando il servizio Google Maps, le recensioni dei clienti passati per decidere se è un buon ristorante o meno, etc.\\\\Il \textbf{Fog computing} è un'architettura orizzontale utile a distribuire senza soluzione di continuità risorse e servizi di calcolo, immagazzinamento di dati, controllo e funzionalità di rete sull'infrastruttura che connette il cloud all'Internet delle cose (IoT). In altri termini, il Fog rappresenta un miglioramento e un'estensione del paradigma Cloud in supporto ad applicazione IoT che debbano rispettare dei precisi parametri di qualità del servizio per essere processati, quali latenza e banda disponibile per determinate connessioni, visto che il Cloud non li supporta efficientemente a causa dello spostamento dei dati dai confini della rete verso strutture di elaborazione centralizzate. 
\section{Metodi di progettazione}
La progettazione e l'implementazione di un'applicazione viene raggiunta seguente dei determinati metodi di progettazione. Lo scopi di tali metodi è di guidare la struttura del software in modo da raggiungere un alto livello di flessibilità e mantenibilità del software. Si tratta di un organizzazione del codice in diverse componenti, in modo la modifica all'interno di un componente non influenzi gli altri. Esistono differenti metodi di progettazione, fra cui :
\begin{itemize}
\item \textbf{MVC} : E' un metodo di progettazione in grado di separare la logica di presentazione dei dati dalla logica di business. Esso è costituito da tre componenti : 
\begin{itemize}
\item \textbf{Modello} cattura il comportamento dell'applicazione in termini di dominio del problema, indipendentemente dall'interfaccia utente. Esso gestisce dirittamente i dati, la logica e le regole dell'applicazione.
\item \textbf{Vista} : si tratta di un qualsiasi rappresentazione in output di informazioni.
\item \textbf{Controller} : si occupa della gestione dei comandi dell'utente ricevuti attraverso il componente precedente e li attua modificando lo stato degli altri due componenti.
\end{itemize}
\item \textbf{MVP} : E' un metodo derivato dal precedente approccio, per facilitare test di unità automatico e migliorare la separazione dei concetti nella logica di presentazione :
\begin{itemize}
\item \textbf{Modello} : è un'interfaccia che definisce i dati da mostrare.
\item \textbf{Vista} : è un'interfaccia passiva che mostra i dati e inoltra i comandi dell'utente al presentatore per agire su tali dati.
\item \textbf{Presentatore} : esso agisce sul modello e sulla vista. In particolare, recupera i dati dal modello e li elabora per mostrarli nella vista.
\end{itemize}
A differenza dell'approccio MVC, il modello e la vista non possono comunicare direttamente.
\item \textbf{MVVM} : un pattern software architetturale costituito dai seguenti elementi :
\begin{itemize}
\item \textbf{Modello} : il modello è un'implementazione del modello di dominio dell'applicazione che include un modello di dati insieme con la logica di business e validazione.
\item \textbf{Vista} : La vista è responsabile della definizione della struttura e l'aspetto di ciò che l'utente vede sullo schermo.
\item \textbf{ViewModel} : esso è un intermediario tra la vista e il modello, ed è responsabile per la gestione della logica e della vista. In altri termini, esso fornisce i dati dal modello in una forma che la vista li può utilizzare facilmente.
\item \textbf{Binder} : è il meccanismo fondamentale di tale pattern, con il quale il view model e la vista vengono costantemente mantenuti sincronizzati. Questo implica che le modifiche ai dati apportate dall'utente attraverso la vista verranno automaticamente riportate nel view model (e viceversa), risparmiando tale onere allo sviluppatore.
\end{itemize}
\end{itemize}
\section{Framework}
Un \textbf{framework} è un framework software progettato per supportare lo sviluppo di siti web dinamici, applicazione web e servizi web. Il suo scopo è quello di alleggerire il lavoro associato allo sviluppo delle attività più comuni di un'applicazione web da parte dello sviluppatore. Molti framework forniscono ad esempio delle librerie per l'accesso alle basi di dati o per la gestione della sessione dell'utente.\\\\Ci sono diversi tipi di applicazioni mobili :
\begin{itemize}
\item siti web per dispositivi mobili : inoltrare i contenuti web ai dispositivi mobili utilizzando lo stile di navigazione dei tradizionali siti web.
\item web mobile : applicazioni web che mimano il comportamento e l'aspetto di applicazioni native, così come la navigazione.
\item Android/iOS native : applicazioni installate sui dispositivi acquistate dall'app store.
\item Ibride : mix fra applicazioni native e web
\item Native : applicazioni in C/C++.
\end{itemize}
\section{Metodologia Agile}
La metodologia Agile si riferisce a un insieme di metodi di sviluppo del software emersi a partire dai primi anni 2000 e fondati su un insieme di principi comuni. La gran parte dei metodi agili tenta di ridurre il rischio di fallimento sviluppando il software in finestre di tempo limitate chiamate iterazioni. Ogni iterazioni è un piccolo progetto a se stante e deve contenere tutto ciò che è necessario per rilasciare un piccolo incremento nelle funzionalità del software : planning, analisi dei requisiti, progettazione, test e documentazione. Anche se viene ottenuto un risultato intermedio, deve comunque essere pubblicato e cercare di avvicinarsi sempre di più alle richieste del cliente nelle successive iterazioni. L'obiettivo di tale metodologia è la completa soddisfazione del cliente. I principi su cui si basa tale metodologia sono i seguenti : le persone e le interazioni sono più importanti dei processi e degli strumenti, è più importante avere software funzionante che documentazione, bisogna collaborare con i clienti oltre che rispettare il contratto, e bisogna essere pronti a rispondere ai cambiamenti oltre che aderire alla pianificazione.
\section{Behavior Driven Design}
Il BDD è una metodologia di sviluppo del software basata sul TDD. Il BDD combina le tecniche generali e i principi del TDD, con idee prese dal domain-driven design e dal design orientato agli oggetti, per fornire agli sviluppatori software degli strumenti e dei processi condivisi per collaborare nello sviluppo software. In particolare esso specifica che i test di una determinata porzione del software devono essere specificati in termini del desiderato comportamento di tale porzione. Il comportamento di ciascuna sezione viene specificato utilizzando delle user stories. Ogni user story adotta la seguente struttura :
\begin{itemize}
\item \textbf{As a} : la persona o il ruolo che beneficerà di tale feature;
\item \textbf{I want} : la feature;
\item \textbf{so that} : il beneficio o il valore della feature.
\end{itemize}
\chapter{Sensori}
I sensori permettono di essere consapevoli dell'ambiente (dove siamo, come ci muoviamo, etc.). Queste informazioni arricchiscono il modo in cui un utente interagisce con lo smartphone. Loro sono dei micro sistemi elettro-meccanici, utilizzati per misurare delle quantità fisiche. In particolare, sono costituiti da due parti :
\begin{itemize}
\item \textbf{Parte meccanica} : essa sfrutta qualche legge fisica
\item \textbf{Parte Elettrica} : essa viene utilizzata per trasdurre la quantità meccanica in un valore elettrico leggibile (per esempio l'accelerazione in volts).
\end{itemize}
Le figure principali di merito di un sensore sono :
\begin{itemize}
\item \textbf{Sensitività} : il voltaggio del segnale di output generato per unità di input
\item \textbf{Larghezza di banda} : l'intervallo delle frequenze nel quale la sensitività rimane costante all'intervallo della banda di tolleranza
\item \textbf{Risoluzione} : il più piccolo incremento di accelerazione misurabile
\item \textbf{Intervallo di misura} : ad esempio +/- 3g
\item \textbf{Rumore} : il più basso valore che può essere letto prima che i dati vengano sovrapposti al rumore elettrico.
\end{itemize}
Un tipo di sensore è il \textbf{sensore inerziale}, il quale sfrutta il concetto di inerzia e la classica legge di newton $F = m\cdot a$. Un'altro tipo di sensore è quello di \textbf{gravità}, il quale sfrutta la legge di gravitazione universale. La sensitività del sensore risulta pari $\frac{M}{K}$. La frequenza naturale è $\omega_n = \sqrt[2]{\frac{K}{M}}$, la quale diminuisce con la sensitività. Un'altro tipo di sensore è il \textbf{sensore giroscopio}, il quale sfrutta la forza di Coriolis. La forza può essere facilmente compresa grazie alla conservazione del momento della forza. Si tratta di una forza apparente che una massa vede quando ad esempio si muove su una traiettoria circolare. Sfortunatamente il magnetometro di uno smartphone non misura solamente il campo magnetico della Terra. Molto spesso in ambienti interni siamo in presenza di dipoli magnetici, i quali perturbano la misura del campo magnetico terrestre. Queste perturbazioni possono esser causate da dispositivi elettromagnetici, strutture oppure altre oggetti ferro magnetici come chiavi, etc. Il \textbf{sensore NFC} si basa sul seguente principio : un campo magnetico variabile $B_1$ generato in una bobina da una corrente variabile potrebbe indurre un'altro campo variabile $B_2$ in un'altra bobina. L'effetto netto della forza di Lorentz nella seconda bobina è una forza elettromotrice. L'energia può essere allora trasferita da un circuito ad un altro. Tale campo trasporta energia che potrebbe attivare un semplice circuito elettronico privo di batteria. Tale circuito potrebbe eseguire delle semplici computazioni e memorizzare i dati. Uno smartphone agisce con un circuito attivo fornendo l'energia. Il circuito passivo viene attivato quando il circuito attivo è abbastanza vicino in modo tale che possano comunicare oppure memorizzare dati. Le lettura dai sensori sono misurate utilizzando il framework del dispositivo.Il \textbf{problema di Wahba} descrive il problema di trovare la matrice di rotazione ottimale partendo da differenti misure (affette da errori o rumore). Ottenere una rotazione precisa è molto importante visto che essa determina la rotazione del dispositivo. La matrice di rotazione contiene tutte le informazioni per determinare l'orientazione. Ogni orientazione può essere espressa come una sequenza di tre differenti rotazioni lungo tre assi differenti (angolo di Eulero) $R = R_x \cdot R_y \cdot R_z$. Possiamo definire diverse tipologie di angolo :
\begin{itemize}
\item \textbf{Azimuth} : l'angolo tra la direzione attuale del compasso del dispositivo e il nord magnetico.
\item \textbf{Pitch} : l'angolo tra il piano parallelo allo schermo del dispositivo e il piano parallelo al terreno.
\item \textbf{Roll} : l'angolo tra il piano perpendicolare allo schermo del dispositivo e il piano parallelo al terreno.
\end{itemize}
I \textbf{quaternioni} sono la generalizzazione di numeri complessi. Le loro unità possono essere utilizzate per rappresentare l'orientazione. L'orientazione è fornita come un vettore e un angolo di rotazione. Tre componenti rappresentano il vettore e una componente l'angolo. Quindi è preferibile rispetto alla matrice di rotazione (4 scalari invece di 9). L' area disponibile per mostrare l'applicazione è chiamata \textbf{viewport}. Un'altro sensore è il \textbf{GPS}, il quale è costituito da tre segmenti : il segmento spaziale, il segmento di controllo e il segmento utente. L'aeronautica militare degli stati uniti sviluppa, gestisce e opera il segmento spaziale e il segmento di controllo. Il segmento spaziale comprende da 24 a 32 satelliti. Il segmento di controllo di compone di una stazione di controllo principale, una stazione di controllo alternativa, varie antenne dedicate e condivise e stazioni di monitoraggio. Il segmento utente infine è composto dai ricevitori GPS. Il principio di funzionamento si basa su un metodo di posizione sferico chiamato \textbf{trilaterazione}, che parte dalla misura del tempo impiegato da un segnale radio a percorrere la distanza satellite-ricevitore. Poiché il ricevitore non conosce il momento in cui è stato trasmesso il segnale dal satellite, per il calcolo della differenza dei tempi il segnale inviato dal satellite è di tipo orario, grazie all'orologio atomico presente sul satellite : il ricevitore calcola l'esatta distanza di propagazione dal satellite a partire dalla differenza tra l'orario pervenuto e quello del proprio orologio sincronizzato con quello a bordo del satellite, tenendo conto della velocità di propagazione del segnale. L'orologio a bordo dei ricevitori GPS è però molto meno sofisticato di quello a bordo dei satelliti e deve essere frequentemente corretto. La sincronizzazione di questo orologio avviene all'accensione del dispositivo ricevente, utilizzando le informazioni che arrivano da un quarto satellite. Se il ricevitore avesse la stessa tipologia di orologio presente nei satelliti, sarebbero sufficienti le informazioni fornite da tre satelliti, ma nella realtà non è così e quindi il ricevitore deve risolvere un sistema di quattro incognite (longitudine, latitudine, altitudine e tempo).
\chapter{Introduzione ad Android}
L'architettura hardware di un dispositivo è costituita da :
\begin{itemize}
\item \textbf{Processore in banda base} : il quale ha il proprio sistema operativo in tempo reale, il quale pone i seguenti vincoli : il software che interagisce con le torri cellulari deve essere certificato, è proibito provare ad accedere alle stazioni di base e ha dei stringenti vincoli temporali.
\item \textbf{Processore dell'applicazione} : esso esegue un sistema Linux basato sul kernel. Esso ha almeno due modalità : utente (non privilegiata) e kernel (privilegiata). Esse sono codificate in un registro della CPU come bits. Ogni tentativo di eseguire un'istruzione privilegia quando tale processore è in modalità utente lancia un'eccezione. L'unico modo per cambiare modalità è utilizzare una specifica istruzione a livello utente (es. chiamata). 
\end{itemize}
Android costruisce un ricco framework sopra al sottostrato di Linux, ma il suo nucleo fa affidamento su Linux per virtualizzare tutte le operazioni. L'ereditarietà di Linux consente ad Android di utilizzare le sue stesse caratteristiche di sicurezza : i permessi, le capacità, SELinux e altre protezioni di basso livello. Il modello di sicurezza di Linux è in relazione con il modello di sicurezza Unix. Questo modello fornisce le seguenti primitive :
\begin{itemize}
\item Ogni utente ha il proprio numero unico identificativo (UID) : due utente potrebbero condividere lo stesso UID, ma questo in effetti significa che, in base a come il sistema è costruito, questo rappresenta un singolo utente con due combinazioni username/password.
\item Ogni utente ha un id numerico di gruppo primario : simile allo username, il nome del gruppo non conta, e alcuni GID sono riservati per il sistema.
\item Un utente può appartenere ad altri gruppi.
\end{itemize}
Android utilizza le precedenti primitive ma offre una differente interpretazione : gli utenti sono concessi per singole applicazioni, non per utenti umani. Un utente non può accedere alle risorse di un altro utente. Questo isolamento consente alle applicazioni di essere eseguite una accanto all'altra, senza essere in grado di influenzarsi a vicenda. Il \textbf{sandboxing} è un'ambiente in cui ogni applicazione durante l'installazione riceve la sua propria home directory. I permessi di Linux assegnati a questa directory permettono solamente al proprietario dell'applicazione di scrivere a e leggere da questa directory. Lo scopo di un permesso è di proteggere la privacy di un utente Android. Le applicazioni Android devono richiedere dei permessi per accedere a informazioni riservate dell'utente, così come per determinate caratteristiche del sistema (es. internet e la fotocamera). Utilizzare i permessi del filesystem per i files e i drivers del dispositivo, è possibile limitare i processi nell'accedere ad alcune funzionalità del dispositivo. Se un'applicazione ha richiesto l'accesso a qualche dispositivo e l'utente l'ha approvato, questa applicazione ha anche assegnato GID del dispositivo.
\section{Applicazioni}
Un'applicazione è generata utilizzando un linguaggio di programmazione. Essa sfrutta le librerie del sistema ma può anche effettuare direttamente delle system calls. Le librerie condivise sono tipicamente collegate al codice a run time. Il codice dell'applicazione e delle librerie viene copiato nella memoria principale e collegate fra di loro. Se due applicazioni utilizzano la stessa libreria, una copia di tale libreria è collegata in qualsiasi applicazione.
\subsection{Applicazioni native}
Le applicazioni native sono applicazioni sviluppate specificamente per un sistema operativo. Esse accedono alle librerie condivise e vengono eseguite direttamente dalla CPU. Vi sono due metodi per sviluppare questo tipo di applicazioni : \textbf{NDK} e \textbf{gcc}. I vantaggi di questo tipo di applicazioni sono : 
\begin{itemize}
\item Maggiore velocità, affidabilità e migliore reattività oltre che una risoluzione superiore che assicura una migliore UX.
\item Semplice accesso a tutte le funzionalità del dispositivo.
\item Notifiche push possibili solamente per questo tipo di applicazioni. Queste notifiche permettono di avvisare gli utenti e di attirare la loro attenzione ogni volte che lo desideriamo.
\item Non necessitano obbligatoriamente di internet per funzionare.
\end{itemize}
Un possibile svantaggio è il loro costo di sviluppo vista la richiesta di sviluppatori esperti per un determinato ambiente e di manutenzione per le diverse versioni da aggiornare per le diverse piattaforme.
\subsection{Applicazioni ibride}
Il meccanismo principale che ci consente di utilizzare java e il codice nativo è il \textbf{Foreign Function Invocation (FFI)}. Esso è un meccanismo attraverso il quale un programma scritto in un linguaggio di programmazione può chiamare routines oppure fare use di servizi scritto in un altro linguaggio. \textbf{Java Native Interface} è un'interfaccia che consente al codice java in esecuzione su una macchina virtuale java (JVM) di chiamare ed essere chiamato da applicazioni native e librerie scritte in altri linguaggi. Essa consente ai programmatori di scrivere dei metodi nativi per gestire situazioni quando un'applicazione non può essere scritta interamente in linguaggio Java, ad esempio quando le librerie Java non supportano una caratteristica specifica della piattaforma. JNI consente ai metodi nativi di utilizzare gli oggetti Java nello stesso modo in cui il codice Java utilizza questi oggetti. Inoltre, è possibile utilizzare codice Javascript dal codice Java dell'applicazione e viceversa. Infatti, basta rendere i metodi che si vogliono condividere lato Android pubblici, inserire l'annotazione @JavascriptInterface e aggiungere l'interfaccia con Javascript all'applicazione.
\subsubsection{Cordova}
Cordova fornisce un insieme di APIs che possono essere utilizzate per accedere ai servizi dei sistemi operativi mobili nativi come Camera, Geolocalizzazione, etc. Per accedere a tali servizi del dsipositivo, vengono utilizzati degli oggetti Javascript attraverso delle chiamate alle APIs di Cordova. La sua architettura è costituita dai seguenti componenti :
\begin{itemize}
\item \textbf{Webview} : essa fornisce un'interfaccia utente di un'applicazione Cordova e può essere anche utilizzata per essere un componente all'interno di un'applicazione ibrida più grande.
\item \textbf{Web App} : essa è definita come la parte principale dove il codice dell'applicazione risiede. E' semplicemente una pagina web creata utilizzando HTML, CSS e Javascript. Tipicamente, viene fornito un file locale (index.html) attraverso il quale è possibile fare riferimento al codice e ad altre risorse che sono necessarie per l'esecuzione dell'applicazione. L'applicazione viene eseguita in una WebView all'interno di un container nativo dell'applicazione, attraverso un motore di rendering HTML. Questo container è costituito da un file principale (config.xml), responsabile della comunicazione delle informazioni sull'applicazione.
\item \textbf{Cordova plugin} : essi sono definiti come una parte integrale dell'ecosistema Cordova che forniscono un'interfaccia per Cordova e per la comunicazione fra componenti nativi. Essi forniscono anche un'interfaccia per le APIs standard del dispositivo (ci consentono di invocare del codice nativo dal codice Javascript). I plugin vengono classificati in \textbf{Principali}, i quali forniscono l'accesso ai servizi del dispositivo all' applicazione come Camera, Batteria, etc., e \textbf{Personalizzati} che forniscono dei bindings addizionali per servizi che non sono necessariamente disponibili su tutte le piattaforme.
\end{itemize}
Quando l'applicazione viene eseguita, Cordova carica la pagina di startup dell'applicazione (index.html) nella WebView dell'applicazione e fornisce il suo controllo alla WebView. Quest'ultima consente ad un utente di interagire con l'applicazione inserendo dei dati nei campi di input, cliccando dei bottoni e osservare i risultati ottenuti. Per accedere ai servizi del dispositivo come Contatti oppure Camera, Cordova fornisce un insieme di APIs Javascript che possono essere utilizzate dai sviluppatori dal loro codice Javascript. Le chiamate verranno tradotto in chiamate di API di codice nativo del dispositivo utilizzando un particolare strato di bridge. Le APIs native possono essere accedute attraverso i plugin di Cordova.
\subsubsection{Xamarine}
To-do
\subsection{Applicazioni mobile web}
Un'applicazione mobile web è un'applicazione che gira su un server web e che viene utilizzata attraverso un browser web, a differenza di una tradizionale applicazione desktop. Questo significa che gli utenti non dovranno installare l'applicazione sui loro smartphone e quindi la capacità di memoria del dispositivo non verrà influenzata. L'interfaccia utente deve essere ottimizzata per i dispositivi mobili che hanno schermi più piccoli e capacità funzionali legate al tocco con le mani. Tipicamente realizzare un'applicazione di questo tipo richiede meno disponibilità economica rispetto alle applicazioni native. Nonostante ciò, esse possono essere molto lente, non sfruttano al massimo le potenzialità del dispositivo e soprattutto sono totalmente dipendenti dalla connessione internet, non è possibile inviare notifiche push.
\subsubsection{Architettura}
L'idea per mostrare un'applicazione mobile web è di evitare di caricare continuamente la pagina di un determinato sito, bensì memorizzarla localmente. Ma come viene mostrata una pagina web nella nostra applicazione ? Viene eseguito il processo di rendering, nel quale il codice HTML viene tradotto, viene creato l'albero del dominio, viene tradotto il codice CSS, rilevando le sue regole e le direttive del layout. In tal modo abbiamo costituito un albero di rendering. In seguito viene eseguito il processo di layout, attraverso il quale viene assegnata la posizione fisica a ogni elemento da mostrare. Le posizioni vengono calcolate in base al viewport (i.e. area sullo schermo) disponibile. Ogni elemento HTML viene mostrato in una scatola chiamata \textbf{modello di scatola CSS}. Le sue dimensioni sono calcolate in base alla propria scatola genitore (container). La scatola genitore di livello più alto rappresenta la scatola del viewport. Molti browser supporta il meta tag viewport, il quale consente di settare il viewport per il processo di rendering. In particolare, esso consente di fornire il reale viewport attuale, così che il rendering viene effettuato sulla dimensione reale. Per gestire differenti viewport possiamo utilizzare due approcci :
\begin{itemize}
\item Creare delle regole CSS per ogni tipologia di schermo. In generale, sono necessarie delle elaborazioni lato server.
\item Definire delle regole CSS per lo schermo attuale, lato client (web reattivo). Esiste un framework chiamato \textbf{Bootstrap 4} che consente di definire delle scatole flessibili per il layout CSS, definendo come un container si adatta al viewport. Tale framework fornisce 5 breakpoints : \textbf{xs} per dispositivi extra small (< 576px), \textbf{sm} per dispositivi small (>= 576px), \textbf{md} per dispositivi intermedi (>= 768px), \textbf{lg} per dispositivi grandi (>= 992px) e \textbf{xl} per dispositivi molto grandi (>= 1200px).
\end{itemize}
\subsection{Processo di compilazione}
Il processo di compilazione coinvolge molti strumenti e processi che convertono il nostro progetto in un Android Application Package (APK). Esso per una tipico modulo di applicazione Android segue questi passi :
\begin{enumerate}
\item i compilatori convertono il codice sorgente in files DEX, i quali includono il bytecode in esecuzione sui dispositivi Android e ogni altra cosa nelle risorse compilate.
\item il gestore dell'APK combina i files DEX e le risorse compilate in un singolo APK. Prima che la nostra applicazione possa essere installata e rilasciata su un dispositivo Android, l'APK deve essere firmata.
\item il gestore dell'APK firma la nostra APK utilizzando la chiave di debug oppure di rilascio :
\begin{itemize}
\item se stiamo compilando una versione di debug dell'applicazione, cioè un'applicazione intesa solamente per profilazione e testing, il gestore firma la nostra applicazione con la chiave di debug.
\item se stiamo compilando una versione di rilascio dell'applicazione che abbiamo intenzione di rilasciare esternamente, il gestore firma la nostra applicazione con la chiave di rilascio.
\end{itemize}
\item prima di generare l'APK finale, il gestore utilizza lo strumento zipalign per ottimizzare l'applicazione in modo da utilizzare meno memoria quando verrà eseguita sul dispositivo dell'utente finale.
\end{enumerate}
Android studio per automatizzare e gestire il processo di compilazione utilizza il toolkit \textbf{Gradle}. La personalizzazione delle configurazioni di compilazione è molto flessibile, infatti possiamo modificare le variabili dell'ambiente di compilazione che troviamo nel file .properties. Il processo di compilazione è controllato da diversi scripts utilizzando un DSL (linguaggio specifico del dominio). Il file setting.gradle comunica a Gradle quali moduli devono essere inclusi quando compiliamo l'applicazione. Il file build.gradle è un file di alto livello che definisce le configurazioni di compilazione che verranno applicate a tutti i moduli del progetto. Per default, tale file utilizza un blocco buildscript per definire le repositories e le dipendenze Gradle che sono comuni a tutti i moduli nel progetto. Possiamo definire diverse tipologie di dipendenze :
\begin{itemize}
\item dipendenza su un modulo di libreria locale : il sistema di compilazione compila il modulo della libreria e incapsula il contenuto compilato nell'APK.
\item dipendenza binaria locale : i files JAR già esistono.
\item dipendenza binaria remota : implementazione di una libreria remota.
\end{itemize}
\subsubsection{Native Development Kit}
NDK è un insieme di strumenti che ci consentono di utilizzare codice C e C++ con Android. Lo strumento di default di compilazione di Android Studio per compilare librerie native è CMake. Esso viene utilizzato per controllare il processo di compilazione del software utilizzando una semplice piattaforma e files di configurazione indipendenti dal compilatore. Esso sfrutta il progetto \textbf{LLVM}. Essa è un'infrastruttura di compilazione scritta in C++, progettata per l'ottimizzazione di programmi in fase di compilazione, di linking, di esecuzione e di non utilizzo. Usando tale approccio, il programmatore può creare una macchina virtuale per linguaggi che la richiedono, un compilatore dipendente dall'architettura considerata e software di ottimizzazione del codice indipendenti dal tipo di linguaggio utilizzato o dalla piattaforma. La rappresentazione intermedia (IR) è indipendente sia dal linguaggio che dall'architettura; essa si pone fra il codice sorgente in un dato linguaggio e un generatore di codice per una specifica architettura. In questa fase il codice viene ottimizzato/trasformato sulla base di specifiche analisi. L'architettura di un'applicazione può seguire i seguenti approcci :
\begin{itemize}
\item E' scritta in Java/Kotlin con pochi metodi scritti in C/C++ che vengono acceduti attraverso la \textbf{Java Native Interface}.
\item Tutte le activity sono implementate in C/C++.
\end{itemize}
\textbf{JNI} è un framework del linguaggi Java che consente al codice Java di richiamare il codice nativo scritto in altri linguaggi di programmazione, come C oppure C++. La sua principale applicazione è quella di richiamare all'interno di programmi Java porzioni di codice che svolgono funzionalità non portabili e che non possono essere implementate in linguaggio Java puro. Tale framework permette ai metodi nativi di utilizzare gli oggetti Java nello stesso modo in cui il codice Java li utilizza. Un metodo nativo può creare, ispezionare e aggiornare questi oggetti. Le funzioni nativi sono implementate in files .c oppure .cpp separati. Quando la JVM invoca la funzione, essa fornisce un puntatore JNIEnv, un puntatore jobject ad qualsiasi altro argomento dichiarato dal metodo Java. Il puntatore JNIEnv è una struttura che contiene l'interfaccia della JVM, la quale include tutte le funzioni necessarie per interagire con la JVM e per lavorare con gli oggetti Java. L'argomento obj è un riferimento all'oggetto Java all'interno del quale il metodo nativo è stato dichiarato. Un tipico utilizzo è la mappatura di tipi di dato nativi a tipi di dato Java.
\chapter{Framework Android}
Adesso introdurremo delle definizioni di alcuni componenti presenti nel framework Android, come :
\begin{itemize}
\item \textbf{Drawable} : esso è un'astrazione generale per qualcosa che può essere disegnato sullo schermo.
\item \textbf{Vista} : essa a differenza del precedente componente è anche in grado di gestire gli eventi.
\item \textbf{Immagine digitale} : un'immagine digitale W x H è una matrice di pixels (Width, Height). Un pixel è la più piccola unità visuale che può essere controllata. Quando si parla di dimensione ci riferiamo al numero totale di pixels. Inoltre, spesso viene definito l'aspect ratio W/H.
\item \textbf{Immagine vettoriale} : essa descrive un' immagine in termini di punti, i quali sono connessi da linee e curve per formare poligoni ed altre forme. I formati più popolari sono : PDF, SVG e EPS.
\item \textbf{Schermo} : Uno schermo ha una superficie X x Y, una diagonale $\sqrt[2]{X^2 + Y^2}$, e un aspect ratio $AR = Y:X$, dove Y è il numero più grande. Spesso le dimensioni degli schermi vengono fornite come la lunghezza della diagonale in inches (1 in = 2.54 cm). E' possibile determinare anche quanti pixel sono presenti per inch (PPI).
\end{itemize}
In generale fornita un'immagine W x H, non possiamo dire nulla sulla sua risoluzione spaziale, questo perchè tale risoluzione dipende dalle dimensioni dello schermo X x Y dove verrà mostrata l'immagine. Ha senso incrementare sempre di più il PPI ? L'occhio umano ha la sua massima risoluzione (300 PPI), così non ha senso andare oltre il limite. Infatti schermi con elevati PPI mappano un pixel software su diversi pixels hardware.
\section{Il sistema delle viste}
Esso è un sistema per organizzare l'interfaccia grafica. \textbf{ViewGroup} è una vista che contiene altre viste (ad esempio il Linear Layout). Un \textbf{container} è un altro tipo di ViewGroup utilizzato per ospitare del contenuto dinamico, oppure del contenuto che non può essere adattato alle dimensioni dello schermo (supporto dello scrolling). La gestione del contenuto dinamico richiede un'implementazione precisa per ottimizzare le prestazioni : il contenuto dovrebbe essere recuperato da uno sorgente lenta (internet), utilizzare un thread separato per eseguire il download di contenuti, gli elementi della vista devono essere aggiunti e aggiornare la vista. Gli \textbf{stili} e i \textbf{temi} su Android ci consentono di separare i dettagli della progettazione dell'applicazione dalla struttura e dal comportamento dell'interfaccia utente. Uno \textbf{stile} è una collezione di attributi che specificano l'apparenza per una singola vista. Uno stile può specificare attributi come il colore e la dimensione del font, il colore di sfondo, etc. Un \textbf{tema} è un tipo di stile che viene applicato all'intera applicazione, non solo ad una singola vista.
\section{Activity}
Un'applicazione è costituita da almeno un'activity, la quale è controllata dalla GUI nello schermo. Essa viene eseguita all'interno del thread principale e dovrebbe reagire all'input dell'utente (gestita dal gestore delle Activity). Le activity nel sistema sono gestite attraverso una pila (back stack). In particolare, quando un activity viene creata, essa viene posizionata in cima a tale pila e diventa attiva. Le activity precedenti rimangono nella pila fino a quando l'activity corrente viene distrutta. L'insieme delle activity lanciate da un utente è chiamato \textbf{Task}. Tutte le componenti dell'applicazione vengono eseguite all'interno del thread principale. Tuttavia, possono essere creati altri thread per eseguire delle operazioni che richiedono molto tempo. \\Ogni activity viene creata dal launcher quando viene spinto l'icona corrispondente. Essa può essere creata anche da un'altra activity oppure da un altro componente software. Un activity può essere in tre differenti stati : esecuzione, pausa e arrestata. Un activity in esecuzione è in primo primo e ha il focus, così l'utente può interagire con essa. Un activity in pausa è parzialmente visibile ma non ha il focus. Questo si può verificare quando un'altra activity viene eseguita ma non ricopre l'intero schermo. Un activity è arrestata quando viene completamente oscurata da un'altra. Le activity in pausa e arrestate possono essere terminate dal sistema quando ha bisogno delle risorse. Quando un activity viene creata, viene chiamato il metodo onCreate(). Esso inizializza tutte le viste, i dati, etc, ed è seguito dal metodo onStart(). Questo metodo è chiamato prima che l'activity diventi visibile e quando l'activity viene riavviata dopo lo stato di arresto (onRestart() -> onStart()). Il metodo onResume() viene chiamato dopo il metodo onStart() oppure quando l'activity viene ripristinata dallo stato di pausa. Il metodo onPause() viene chiamato prima del ripristino di un'altra activity. Esso è utilizzato per eseguire il commit di cambiamenti non salvati e per arrestare i threads, le animazioni, etc. Esso deve essere veloce perchè l'altra activity non può essere ripristinata fino a quando l'activity corrente non abbia terminato i processi sopra citati. Il metodo onStop() è chiamato quando l'activity non è più visibile all'utente. Se l'activity viene ripristinata, questo metodo è seguito da onRestart(), altrimenti se l'activity deve essere distrutta viene chiamato il metodo onDestroy(). Per memorizzare un piccolo ammontare di dati che possono essere serializzati e deserializzati può essere utilizzato un \textbf{Bundle}. Tuttavia, esso diventa inefficiente al crescere dell'ammontare dei dati da memorizzare. Android risolve tale problema, fornendo un modo per memorizzare i dati attraverso il \textbf{ViewModel}. Un activity è creata se è il target di un messaggio speciale chiamato \textbf{Intent}.
\subsection{Intent}
Un intent viene classificato in :
\begin{itemize}
\item \textbf{Unicast} : intent intesi solamente per uno specifico componente oppure per una determinata azione da compiere. Gli intent di questo tipo si dividono in :
\begin{itemize}
\item \textbf{Espliciti} : quando il target dell'intent è dichiarato all'interno di esso.
\item \textbf{Impliciti} : quando l'intent specifica solamente l'azione che il componente dovrebbe compiere. Se sono disponibili diverse activity che possono eseguire l'azione richiesta, allora l'utente ha bisogno di selezionarne una.
\end{itemize}
\item \textbf{Broadcast} : intent che comunica delle informazioni a tutti i componenti (vedi Broadcast Receivers).
\item \textbf{Pending} : intent con i quali possono essere attivati dei componenti in futuro (utilizzato per le notifiche).
\end{itemize}
Gli intent consentono di chiamare un'activity ed ottenere il risultato. L'activity chiamante non attenderà in modo sincrono il risultato, ma l'activity chiamata quando avrà elaborato il risultato chiamerà il metodo setResult, il quale eseguirà il metodo onActivityResult dell'activity chiamante. Quando un'activity vuole passare dei dati ad un'altra activity, ha bisogno di settare dei campi extra nell'intent. Ad esempio, possiamo raggiungere questo scopo utilizzando un bundle, il quale può inglobare tipi di dato primitivi e strutture dati. \\Un \textbf{intent-filter} è un'espressione nel manifesto dell'applicazione che specifica il tipo di intent che il componente vorrebbe ricevere. Dichiarando un intent filter per un activity, rendiamo possibile ad altre applicazioni di lanciare direttamente tale activity con un determinato tipo di intent. Ad esempio, supponiamo che l'activity A nel package PA vuole chiamare l'activity B nel package PB. L'activity B definisce un intent-filter contenente un'azione personalizzata e la categoria di default. L'activity A crea un intent con l'azione personalizzata e chiama startActivity. Il sistema trova il componente appropriato da eseguire confrontando il contenuto dell'intent con il contenuto dell'intent filter dichiarato nel manifesto di altre applicazioni sul dispositivo. Le activity vengono eseguite come due utenti separati.\\Un \textbf{Broadcast Receiver} è un componente che ci consente di registrare gli eventi di un'applicazione o del sistema. Tutti i ricevitori registrati per un evento vengono notificati da Android una volta che l'evento si verifica. La parte di implementazione della registrazioni consiste nella creazioni di un intent filter per indicare gli specifici intent broadcast cui il ricevitore deve ascoltare. Questo è raggiunto attraverso il riferimento della stringa dell'azione dell'intent broadcast. Quando viene trovata una corrispondenza broadcast, il metodo onReceive() del ricevitore viene chiamato; a questo punto il metodo ha a disposizione 5 secondi per eseguire le attività necessarie prima di restituire il controllo. I ricevitori broadcast non hanno bisogno di essere eseguiti di continuo. Gli intent broadcast sono degli oggetti intent che sono broadcast attraverso una chiamata al metodo sendBroadcast() della classe Activity(). Inoltre, per fornire un sistema di comunicazione tra le componenti dell'applicazione, gli intent broadcast vengono anche utilizzati dal sistema Android per notificare le applicazioni interessate per quanto riguarda gli eventi principali del sistema (ad esempio la connessione/disconnessione dell'alimentazione elettrica).
\section{Permessi}
Android è un sistema operativo a privilegi separati, nel quale ogni applicazione viene eseguita con una diversa identità di sistema (Linux user id e group id). Le parti del sistema sono anche separate in diverse identità. In tal modo, Linux separa le applicazioni l'una dalle altre e dal sistema. Visto che ogni applicazione Android opera in un processo sandbox, le applicazioni devono richiedere esplicitamente i permessi a loro necessari per ulteriori capacità non fornite nella sandbox, nel manifesto. Dipende da quanto l'area è sensibile, il sistema potrebbe consentire i permessi automaticamente oppure potrebbe chiedere all'utente se approvare oppure rifiutare la richiesta. Quando un permesso viene concesso per un' applicazione, il sistema assegnerà un Group id supplementare corrispondente al permesso. Se la piattaforma del dispositivo è Android 6.0 (livello API 23) o superiore, e il targetSdkVersion dell'applicazione è 23 o superiore, l'applicazione richiederà i permessi all'utente a tempo di esecuzione. Un utente può revocare i permessi in qualsiasi momento, così l'applicazione ha bisogno di controllare se ha i permessi ogni volta che viene eseguita. Se la piattaforma del dispositivo è Android 5.1 (livello API 22) o inferiore, oppure se il targetSdkVersion è 22 o inferiore, il sistema chiederà di fornire i permessi quando l'utente installerà l'applicazione. Se aggiungiamo un nuovo permesso ad una versione aggiornata dell'applicazione, il sistema chiederà all'utente di consentire tale permesso quando l'utente aggiornerà l'applicazione.
\section{Servizi}
Un servizio è un componente dell'applicazione che può eseguire delle lunghe operazioni in background, il quale non fornisce alcuna interfaccia utente. Il ciclo di vita dei servizi è indipendente dal componente che lo ha lanciato, così loro possono continuare la loro esecuzione anche se tale componente ha terminato la sua esecuzione. I servizi si dividono in due categorie :
\begin{itemize}
\item \textbf{Foreground} : un servizio di questo tipo esegue alcune operazioni che sono visibile all'utente. Per esempio, un'applicazione per la musica potrebbe utilizzare un servizio di foreground per procedere con l'esecuzione di un brano. Essi devono mostrare un'icona nella barra di stato del dispositivo, invocando tipicamente il metodo startForeground(id, notification). Il sistema difficilmente terminerà questo tipo di servizi.
\item \textbf{Background} : un servizio di background esegue un operazione non direttamente visibile all'utente. Per esempio, se un'applicazione utilizza un servizio per comprimere la memoria che utilizza, questo sarà probabilmente un servizio di background. Il sistema ha più probabilità di terminare un servizio di background rispetto a uno di foreground. A partire da Oreo, per ragioni di prestazioni il sistema impone delle restrizioni sui servizi di background in esecuzione quando l'applicazione stessa non è in foreground. Per eseguire delle operazioni di background viene raccomandato l'utilizzo dello \textbf{Scheduled Job}.
\end{itemize}
I servizi possono assumere due comportamenti :
\begin{itemize}
\item \textbf{Started service} : esso esegue una singola operazione e non restituisce il risultato direttamente al chiamante. Il servizio può essere eseguito in background indefinitivamente, anche se il componente che lo ha lanciato viene distrutto. Loro vengono eseguiti chiamando la funzione startService(). Quando il servizio ha completato la sua attività, esso dovrebbe chiamare il metodo stopSelf(). Alternativamente, un servizio in esecuzione può essere arrestato chiamando il metodo stopService(). Il metodo onBind() deve restituire null.
\item \textbf{Bound service} : esso offre un'interfaccia client-server che consente ai componenti di interagire con il servizio, inviare richieste, ricevere risultati e persino fare questo fra processi con la comunicazione fra processi (IPC). Un servizio di questo tipo verrà eseguito fino a quando il componente a cui seguito continuerà l'esecuzione. Loro vengono lanciati con una chiamata al metodo bindService(), ma permettono delle interazioni con il componente che li ha lanciati. Diversi componenti possono essere collegati ad uno stesso servizio simultaneamente. Per dissociarsi un servizio, un componente chiama il metodo unbindService(). Quando tutti i clienti collegati ad un servizio vengono dissociati, il sistema lo termina. Un servizio di questo tipo può essere anche lanciato con una chiamata a startService() e poi i componenti possono associarsi ad esso invocando la funzione bindService(). In questo caso il servizio non verrà terminato quando tutti i clienti si saranno dissociati da esso.
\end{itemize}
Lo \textbf{JobScheduler} viene utilizzato quando un'attività non richiede un tempo esatto, ma potrebbe essere schedulato basato sulla combinazione dei requisiti dell'utente e del sistema. Per esempio, un'applicazione potrebbe aggiornare le notizie di mattina, ma potrebbe attende fino a quando il dispositivo sarà carico e connesso al wifi per aggiornarle, per preservare le risorse del sistema e i dati dell'utente. Tale classe permette di stabilire le condizioni oppure i parametri per eseguire una determinata attività. Inoltre, esso calcola il miglior istante temporale per schedulare l'esecuzione dell'attività richiesta. \\Un servizio viene eseguito sul thread principale, così se esso deve eseguire una lunga operazione dovrebbe creare un nuovo thread che esegue tale attività. \textbf{Intent Service} semplifica tale operazione. Intent Service è una sottoclasse di Service e predispone un thread per gestire le attività in background asincronamente. Inoltre, essa processa una richiesta alla volta in base alla politica FIFO. Una volta che il servizio ha gestito tutte le richieste, esso termina. Per processare una richiesta, il metodo onHandleIntent() viene chiamato, così il programmatore deve implementarlo. Visto che Intent Service è un servizio, deve essere necessariamente registrato nel manifesto dell'applicazione.
\section{Frammento}
Un frammento è una parte di un activity, il quale contribuisce all'interfaccia utente di tale activity. Un frammento può essere pensato come ad una sotto activity, mentre lo schermo completo con il quale l'utente interagisce è chiamato come activity. Un activity funge da collante per diversi frammenti. Un frammento ha il proprio layout e comportamento, così come un proprio ciclo di vita. Possiamo aggiungere oppure rimuovere dei frammenti in una singola activity per costruire un interfaccia utente multi riquadro. Un frammento può essere utilizzato in diverse activity. Il ciclo di vita di un frammento è strettamente in relazione con il ciclo di vita dell'activity ospitante. Ad esempio, quando un activity è messa in pausa, tutti i frammenti disponibili nell'activity verranno messi in pausa. I frammenti hanno delle callback extra rispetto alle activity, per gestire le interazioni con l'activity per eseguire azioni con la costruzione o distruzione dell'interfaccia utente del frammento. Questi metodi addizionali sono :
\begin{itemize}
\item onAttach() chiamato quando il frammento è stato associato con un activity.
\item onCreateView() chiamato per creare la gerarchia delle viste associata al frammento.
\item onActivityCreated() chiamato al completamento del metodo onCreate() dell'activity ospitante.
\item onDestroyView() chiamato quando la gerarchia delle viste associata al frammento viene rimossa.
\item onDetach() chiamato quando il frammento viene dissociato dall'activity.
\end{itemize} 
Android fornisce un manager chiamato \textbf{Fragment Manager} per aggiungere/rimuovere/trovare un frammento. Tipicamente, tale manager utilizza un \textbf{FrameLayout} per fornire l'area dove il frammento mostrerà la propria vista. Quando un frammento è creato programmaticamente, l'activity ospitante può utilizzare un Bundle per fornire dei dati al frammento. Diversi frammenti in una stessa activity possono comunicare utilizzando l'activity ospitante.
\section{RecyclerView}
E' una tipologia di vista che ci permette di mostrare una lista di dati. Le liste possono essere molto complesse, possono mostrare una serie di destinazioni, oppure dei dati inerenti a transazioni, etc. I benefici nell'utilizzare questa vista sono i seguenti :
\begin{itemize}
\item Per default, RecyclerView processa solamente gli elementi attualmente presenti sullo schermo. Quando l'utente effettua uno scrolling, tale componente si accorge che dei nuovi elementi devono essere mostrati ed effettua abbastanza lavoro per mostrarli.
\item Quando un elemento non è più visibile sullo schermo, la sua vista viene riciclata. Ciò significa che la sua vista verrà riutilizzata da un'altro elemento, aggiornando il rispettivo contenuto.
\item Quando un elemento cambia, invece di progettare l'intera lista, tale componente può aggiornare solamente tale elemento.
\end{itemize}
Essa utilizza un adattatore per trasformare i dati dell'applicazione in qualcosa che lei può mostrare, senza influenzare il processamento di tali dati da parte dell'applicazione.
\textbf{Position Independent Executable (PIE)} è un corpo di una macchina che, posizionato nella memoria principale, esegue correttamente senza tenere conto del suo indirizzo assoluto. Esso viene comunemente utilizzato per le librerie condivise, così che il codice della stessa libreria può essere caricato in una locazione dello spazio degli indirizzi di ciascun programma. Esso può essere eseguito a qualsiasi indirizzo di memoria senza alcuna modifica, evitando il tempo necessario per la rilocazione degli indirizzi. Inoltre, viene aumentata la sicurezza rispetto al buffer overflow, visto che gli indirizzi delle funzioni di libreria e delle più importanti aree di memoria vengono randomizzati (\textbf{Address Space Layout Randomization}). In questo modo l'attaccante che cerca di eseguire del codice malevolo su un computer è costretto a cercare gli indirizzi del codice e dei dati che gli servono prima di poterli utilizzare, causando una serie di crash del programma. Infatti, accedendo ad un indirizzo errato, si ottengono dati errati, e se viene chiamata una funzione con l'indirizzo errato si genererà un'eccezione, causando la terminazione del programma. L'attaccante può sfruttare queste eccezioni per collezionare sempre più informazioni in modo da riuscire a conoscere prima o poi il corretto indirizzo di memoria di cui necessita. Questa attività di raccolta di informazioni genera una serie di crash del programma, che quindi sono ben visibili all'utente. Gli utenti Linux utilizzano una memoria virtuale e lo scambio di files. Android normalmente non utilizza lo scambio di files per ragioni di efficienza. \textbf{Out of memory} è uno stato che indica che non è possibile allocare della memoria per l'utilizzo di programmi o del sistema operativo. In android, OOM killer è differente da quello tradizionale di Linux, visto che i processi sono classificati in base allo stato dell'applicazione corrente. Dopo che un'applicazione è stata terminata per richiedere risorse, può essere ripristinata, visto che il sistema operativo memorizza lo stato dell'applicazione. Un'applicazione Android in esecuzione è costituita da diversi processi, classificati come foreground, visibili, servizi, nascosti e vuoti. Per consentire lo scambio delle informazioni fra processi viene utilizzato \textbf{Inter-Process Communication}. Esso viene regolato dal \textbf{Binder}, il quale è un framework che contiene un oggetto centrale chiamato Binder driver che si occupa di gestire tutte le chiamate IPC. Il meccanismo di alto livello del Binder è chiamato \textbf{Intent}. Un intent è un oggetto di messaggistica che può essere utilizzato per richiedere un' azione da un'altro componente dell'applicazione. Esso supporta la comunicazione fra le componenti dell'applicazione, ma può essere utilizzato anche per lanciare un Activity, un servizio e per consegnare un messaggio broadcast. Un intent può essere esplicito se viene specificato il componente da eseguire, oppure implicito se viene solamente specificata l'azione da eseguire.
\chapter{Web API}
\section{Remote Procedure Call}
Una RPC è quando un programma invoca una procedura per eseguirla su una macchina differente da quella su cui è in esecuzione il programma. Il chiamante (client) realizza una chiamata locale al componente software (stub) che comunica con l'oggetto remoto. Nel lato chiamato (server) c'è un componente (scheletro) che riceve la chiamata allo stub e realizza una chiamata locale al codice del server. RPC utilizza il protocollo http e i dati sono rappresentati in JSON oppure XML. Generalmente, il flusso di esecuzione di RPC è il seguente :
\begin{enumerate}
\item Il client chiama il proprio stub come in una tradizionale chiamata a procedura locale.
\item Lo stub del client inserisce i parametri in un messaggio e realizza una chiamata di sistema per inviare il messaggio.
\item Il sistema operativo del client invia il messaggio dalla macchina del client alla macchina del server.
\item Il sistema operativo del server fornisce i pacchetti in entrata allo stub del server.
\item Lo stub del server estrae i parametri del messaggio.
\item Infine, lo stub del server chiama la procedura del server.
\end{enumerate}
La risposta segue gli stessi passi, ma in ordine inverso.
\subsection{XML-RPC}
Esso è un protocolo RPC il quale utilizza XML per codificare i dati. I dati che possono essere convertiti in XML sono scalari, arrays oppure structs. Esso invia una richiesta http al server che implementa il protocollo. Ci sono tre tipi di messaggio : messaggio di richiesta, messaggio di risposta e messaggio di errore. L'elemento principale del messaggio di richiesta è il \textbf{methodCall}. Esso contiene gli elementi methodName e params. Il primo contiene il nome della procedura chiamata e il secondo contiene una lista di valori per i parametri della procedura. L'elemento principale del messaggio di risposta è \textbf{methodResponse}. Esso contiene un elemento params, il quale è una lista di valori.
\subsection{JSON-RPC}
Esso è un protocollo RPC il quale utilizza JSON per codificare i dati. La richiesta deve contenere tre proprietà : \textbf{metodo} è una stringa con il nome del metodo da invocare, \textbf{params} è un array di oggetti da fornire come parametro al metodo definito e \textbf{id} è un valore di un qualsiasi tipo, utilizzato per abbinare la risposta con la richiesta a cui stà rispondendo. Anche il responso deve contenere tre proprietà : \textbf{result} sono i dati restituiti dal metodo invocare, se un errore si verifica mentre invochiamo il metodo, questo valore deve essere null, \textbf{error} è uno specifico codice di errore se si verifica un errore, altrimenti è null, \textbf{id} è l'id della richiesta a cui si stà rispondendo. E' possibile utilizzare le notifiche : in questo caso l'id deve essere settato a null. JSON-RPC può essere utilizzato come un semplice sistema di richiesta e responso, oppure per inviare delle notifiche a tutti i clients.
\subsection{REST}
Essa è la più semplice forma di RPC. Le richieste sono mappate a metodi HTTP (GET, POST). Il nome del metodo è un parametro della chiamato e il risultato può essere formattato come dati XML oppure JSON. Il suo nome deriva da RESTful Web Services : il protocollo è stateless, ogni risorse è identificata da un URI e le operazioni CRUD sono mappate a verbi HTTP (POST, GET, PUT, DELETE)
\section{Gestione delle risorse}
Naturalmente, bisogna gestire le risorse sulla base di diversi aspetti :
\begin{itemize}
\item \textbf{Autenticazione} : stabilire un'associazione di fiducia tra il client e l'identità del principale.
\item \textbf{Autorizzazione} : determinare quali risorse e operazioni un'utente autenticato può eseguire.
\item \textbf{Controllo dell'accesso} : controllare se un operazione su una risorse è consentita, ad esempio possiamo controllare la validità del token di accesso che viene rilasciato ad un utente dopo aver effettuato l'autenticazione.
\item \textbf{Tasso di controllo} : un controllo sul numero massimo di richieste da processare.
\end{itemize}
Quando recuperiamo i dati da una sorgente lenta, sono più appropriate delle chiamate asincrone, altrimenti l'interfaccia utente viene bloccata. In particolare, l'utente invia la richiesta e procede con il suo proprio flusso di esecuzione. Quando le risorse saranno pronte, riceverà una notifica. Per aggiornare delle risorse effettuiamo prima dei cambiamenti sulla nostra copia locale, poi li aggiorniamo asincronamente. Se la rete non è disponibile utilizziamo un database locale e un meccanismo di sincronizzazione che verrà eseguito quando la rete sarà nuovamente disponibile. Ad esempio, nel caso di una READ quando la rete è disponibile, restituisco un elemento placeholder, recupero i dati aggiornati e sostituisco il placeholder. Nel caso in cui la rete non fosse disponibile, mostro un messaggio all'utente. Ad esempio, nel caso di una CREATE, se la rete è disponibile utilizzo un thread secondario per aggiornare il server, altrimenti memorizzo tale richiesta. Quando la rete sarà disponibile, le operazioni appese saranno eseguite in sequenza.\\\\Quando diversi utenti (applicazioni) condividono un singolo dato su cui vengono eseguite delle operazioni di lettura e scrittura concorrenti, la sua consistenza potrebbe essere un problema (Teorema CAP). \textbf{Firebase} è un database in tempo reale che si occupa di questi problemi. In caso di un file, la sincronizzazione è gestita da uno speciale algoritmo e i conflitti vengono risolti, ad esempio realizzando una copia dei dati.
\section{JSON Web Token}
Esso è uno standard Internet per creare dei token di accesso basati su JSON che sostengono un determinato numero di richieste. Per esempio, un server potrebbe generare un token che viene assegnato alla richiesta del login come amministratore, e lo fornisce al client. Il client potrebbe utilizzare il token per provare che è loggato come amministratore. I tokens sono firmati con la chiave privata del server, così che entrambi possono verificare se il token sia legittimo o meno. Un token è costituito da tre informazioni : \textbf{Header}, il quale identifica quale algoritmo è stato utilizzato per generare la firma, il \textbf{Payload} che contiene una serie di richieste e la \textbf{firma}, il quale valida in sicurezza il token. Le richieste standard che possono essere inserite nel payload sono :
\begin{itemize}
\item iss : identifica l'ente che ha rilasciato il token.
\item sub : identifica l'ente a cui è stato rilasciato il token.
\item aud : identifica il destinatario del token. Ogni ente che rilascia dei token deve auto identificarsi con un valore, altrimenti il token deve essere rifiutato.
\item exp : rappresenta la data di scadenza del token, dopo la quale esso non deve essere accettato.
\item nbf : rappresenta la data di inizio di validità del token.
\item iat : identifica la data in cui è stato rilasciato il token.
\item jti : identificatore unico (case sensitive) del token anche fra differenti issuers.
\end{itemize}
\chapter{Cloud Computing}
Il \textbf{Cloud Computing} è un modo per utilizzare le infrastrutture IT senza il bisogno di installare uno specifico hardware relativo all'infrastruttura da utilizzare. L'infrastruttura IT può essere una macchina virtuale, una piattaforma software utilizzata per sviluppare ed eseguire applicazione su diverse macchine, oppure un'applicazione software. Una delle caratteristiche principale del Cloud Computing è la capacità di fornire risorse astratte, oppure risorse virtualizzate fornite come un servizio e con una propria interfaccia. Le tipologie principali di CC sono :
\begin{itemize}
\item \textbf{IaaS} : Essi sono dei servizi di cloud computing che forniscono APIs di alto livello utilizzate per dereferenziare vari dettagli di basso livello dell'infrastruttura di rete considerata. Questi servizi sono sostenuto da data centers su larga scala costituiti da migliaia di computers. Tutte le istruzioni di un programma sono eseguiti all'interno di una macchina virtuale : questa fornisce isolamento, sicurezza, affidabilità e migliori prestazioni. Un'altra caratteristica fondamentale di tale infrastruttura è la mobilità dell'applicazione. Questo viene raggiunto incapsulando il sistema operativo ospite all'interno della macchina virtuale e consentendo di essere sospeso, completamente serializzato, migrato ad una piattaforma differente e ripristinato immediatamente oppure memorizzato per un futuro ripristino. Ci sono due tipologie di macchine virtuali : \textbf{native} ed \textbf{emulate}. Le macchine virtuali native sono costituite da una macchina logica che viene eseguita sulla stessa macchina fisica. Macchine logiche e fisiche possiedono lo stesso ISA e le istruzioni sulle macchine fisiche sono in gran parte eseguite su una CPU reale. Nella macchine virtuali emulate, le macchine fisiche e logiche sono differenti e possono avere ISA differenti. E' presente un hardware e un livello di linguaggio (Java) di emulazione.
\item \textbf{PaaS} : Essa è una piattaforma che offre un ambiente in cui gli sviluppatori creano e rilasciano le applicazioni. Essa supporta differenti linguaggi di programmazioni (Java, Ruby) e databases. Gli utenti posso decidere la dimensione della macchina virtuale, la locazione, etc. e avere una console web per creare applicazioni. Loro possono utilizzare un IDE per sviluppare un'applicazione ed utilizzare un SDK o CLI per rilasciarla. I vantaggi principali di tale tipologia di CC sono : consente programmazione di alto livello riducendo la complessità, l'intero processo di sviluppo dell'applicazione è più efficiente visto che utilizza un'infrastruttura built-in, la manutenzione dell'applicazione è semplice. Alcuni svantaggi sono : gli sviluppatori potrebbero non essere in grado di utilizzare tutti gli strumenti convenzionali, ritrovandosi così bloccati in determinate piattaforme. Un esempio di PaaS è il motore delle app di Google; infatti, esso è un servizio cloud per eseguire applicazioni web nel data center di Google. Ha una trasparente scalabilità, semplice configurazione e supporta diversi linguaggi di programmazioni. Le applicazione vengono eseguite all'interno di una sandbox per ragioni di sicurezza.
\item \textbf{SaaS} : SaaS è un modello di cloud computing nel quale un provider ospita delle applicazioni e le rende disponibili ai clienti in rete. Esso offre un elevata scalabilità e dei pagamenti flessibili, il quale consente ai clienti di accedere a dei servizi addizionali su richiesta. Molte applicazioni SaaS possono essere eseguite direttamente da un browser web, senza alcuni download o installazione richiesta, richiedono solamente alcuni plugins. Con SaaS è semplice per le aziende ottimizzare la loro manutenzione e il supporto, visto che ogni cosa può essere gestita dai fornitori : applicazioni, dati, middlewares, virtualizzazione, etc. Un esempio di SaaS sono le applicazioni di Google.
\end{itemize}
\chapter{Memorie}
Dove memorizzare i dati di un'applicazione ? Abbiamo le seguenti possibilità :
\begin{itemize}
\item \textbf{SharedPreference} : consente di memorizzare dati privati (booleani, float, int, long e string) come coppie chiave-valore. E' una buona opzione per un piccolo ammontare di dati (es. stato di un gioco).
\item \textbf{Preference} : è stato aggiunto in android X, per memorizzare le preferenze di un utente mostrate a quest'ultimo tramite le impostazioni dell'applicazione.
\item \textbf{Memoria interna} : può essere utilizzata la memoria interna del dispositivo per memorizzare i dati di un utente. Tipicamente viene creata una cartella privata quando l'applicazione viene installata.
\item \textbf{Memoria esterna} : può essere utilizzata la memoria esterna del dispositivo (SD) per memorizzare i dati di un utente, i quali sono accessibili da chiunque.
\item \textbf{SQLite} : possiamo memorizzare i dati in un database con una determinata struttura dei dati. Viene raccomandato l'accesso attraverso la \textbf{Room Persistency Library}, con il quale la correttezza delle query verrà controllata a tempo di compilazione. Per accedere ai dati dell'applicazione utilizzando tale libreria, dobbiamo lavorare con i \textbf{Data Access Objects (DAO)}. Questo insieme di oggetti DAO costituisce il componente principale di Room, visto che ogni DAO include dei metodi che offrono un'accesso astratto al database dell'applicazione. Accedere al database utilizzando questi oggetti, ci permette di separare differenti componenti dell'architettura del database. Prima di tutto per utilizzare un DAO come interfaccia bisogna inserire l'annotazione @Dao. Per le operazioni CRUD verranno utilizzate le rispettive notazioni @Insert, @Query(query to ask), @Update e @Delete.
\item \textbf{Provider di contenuti} : esso è una repository di informazioni condivise fra diverse applicazioni. Fornisce un pieno controllo per le operazioni di lettura e scrittura, e un'interfaccia uniforme che può essere implementata in un file oppure in un database. Esempio di provider di contenuti sono Contatti, Calendario, etc. L'URI che viene utilizzato per richiedere una determinata informazione assume la seguente forma $content://authority/path/id$, dove content significa che vogliamo accedere al provider di contenuti, authority rappresenta il nome del provider, path è 0 oppure diversi segmenti che indicano i dati a cui vogliamo accedere e id specifica l'elemento. Possiamo utilizzare un provider di contenuti attraverso un intent con target il provider stesso. Inviare un intent all'applicazione contatti del dispositivo ci consente di accedere al provider dei contatti indirettamente. Infatti, l'intent lancia l'interfaccia utente dell'applicazione contatti del dispositivo, nel quale un utente può effettuare delle operazioni relative ai contatti. In questo modo l'utente può prendere un contatto dalla lista e restituirlo all'applicazione, modificare i dati di un contatto esistente, inserire un nuovo contatto e rimuovere un contatto.
\end{itemize}
La libreria DataBinding consente di associare dei valori nel layout ad un oggetto di dati. Essa consente di aggiungere dei listeners e notificare il cambiamento dei dati all'interfaccia utente. \textbf{Firebase} è un database in tempo reale. Molti database richiedono delle chiamate HTTP per ottenere e sincronizzare dei dati. Quando colleghiamo la nostra applicazione a Firebase, non ci stiamo connettendo attraverso una normale chiamata HTTP, ma ci stiamo connettendo attraverso una WebSocket. Esse sono molto più veloci di HTTP. Tutti i nostri dati verranno aggiornati automaticamente attraverso una singola WebSocket con una velocità proporzionale alla rete dell'utente. Quando un utente modifica dei dati, tutti gli utenti connessi ricevono i dati aggiornati quasi istantaneamente.
\end{document}